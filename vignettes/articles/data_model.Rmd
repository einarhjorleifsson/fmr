---
title: "The data model"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>"
)
```

```{r}
library(fmr)
library(tidyverse)
```

## Preamble

This document is just to explore the FM data model, done to prevent any misunderstanding when setting up the downstream code. In addition it deals with some issues and questions that arise related to the data-entry of catch-sample data.

The FM API on is made up from three tables ([The Data Structured Explained](https://fimsehf.atlassian.net/wiki/x/zgC7ww)).

1. Survey table - distinguished by survey_id
2. Survey detail table - distinguished by survey_item_id
3. Survey item table - distinguished by survey_item_dtl_id

The conceptual design (if one is considering catch-sampling on landing sites) is depicted as:

```{r, echo = FALSE}
#| fig.cap: "Source: Fisheries Technologies."
knitr::include_graphics(here::here("vignettes/articles/data_model1.png"))
```

The FM 3 table framework is not specific for sampling from landings, but lets here think about these three tables in that context.

1. Sampling site table (survey table): For catch-sampling from landings data one could imagine that each record represents information about the sampling from a particular sampling site on a particular sampling date (this though not the necessary case as discussed below).
2. Trip table (surveyitem table): In case of catch sampling from landings this table should contain all information related to a single fishing trip except details of catch.
3. Catch table (surveyitem detail table): In case of catch sampling from landings this table will contain the detailed information about catch by species.

## The connection

...


```{r, eval = FALSE}
key <- "your_FM_API_key"
```

```{r, echo = FALSE, include = FALSE}
key <- Sys.getenv("fm_key")
```

## The three survey tables

### The landing site-date table (Survey table)

Information about each (landing) survey can be retrieved with the {fmr::fm_survey}-function. 
The data can obtained by:

```{r}
s1 <- fm_survey(key, trim = FALSE)
s1 |> glimpse()
```

Each survey is identified by a unique value stored as *.s1* (*survey_id*). Intuitively one expects that each survey id constitutes a unique number for each landing site (*site*) by each sampling day (*date*). This is however not necessarily the case, as demonstrated below.

#### What does a single survey_id (.s1) represent?

```{r}
s1 |> 
  # look at one month
  filter(floor_date(date, unit = "month") == ymd("2024-01-01"),
         site == "Basseterre East") |>
  arrange(date) |> 
  group_by(site, date) |> 
  summarise(n_surveyid = n_distinct(.s1),
            .groups = "drop") |> 
  knitr::kable(caption = "Number of surveys per date")
```

One could implement a unique id within the R-function, named e.g. *.sid*. We can test that via:

```{r}
s1 <- 
  s1 |> 
  # just so we can get the original order back
  mutate(.rowid = 1:n()) |> 
  arrange(site, date, T1) |> 
  mutate(.sid = dplyr::consecutive_id(site, date)) |> 
  arrange(.rowid) |> 
  select(-.rowid)
s1 |> 
  summarise(n_sid = n_distinct(.sid),
            n_surveyid = n_distinct(.s1),
            .groups = "drop")
```

One would use this table e.g. to get an overview of the reported sampled dates:

```{r, fig.width = 9, fig.height = 9}
fm_survey(key, trim = FALSE) %>% 
  filter(year(date) == 2024,
         month(date) == 1) |> 
  select(site, date) |> 
  distinct() |> 
  mutate(survey = TRUE) |> 
  fm_grid_calendar() |> 
  mutate(weekend = ifelse(.wday %in% c("Sa", "Su"),
                          TRUE,
                          FALSE)) %>% 
  #filter(site == "Charlestown") |> 
  ggplot(aes(.wday, .week)) +
  theme_bw() +
  geom_tile(aes(fill = survey)) +
  facet_wrap(~ site) +
  geom_text(aes(label = .day, colour = weekend)) +
  scale_fill_manual(values=c("grey80", "pink")) +
  scale_colour_manual(values = c("black", "red")) +
  scale_y_reverse(NULL, NULL) +
  labs(x = NULL,
       title = "January 2024",
       caption = "colour: reported sampling day") +
  coord_equal() +
  theme(legend.position = "none",
        legend.title=element_blank(), 
        panel.grid=element_blank(), 
        panel.border=element_blank(), 
        axis.ticks=element_blank(), 
        strip.background=element_blank(), 
        #legend.position="top", 
        legend.justification="right", 
        legend.direction="horizontal", 
        legend.key.size=unit(0.3, "cm"), 
        legend.spacing.x=unit(0.2, "cm"))
```

#### Some issues

Do not expect that one can create a survey without a survey date:

```{r}
s1 |> 
  filter(is.na(date)) |> 
  select(.s1, site, date, status, T1, T2, n_boats = total_boats, comment,
         .cn:.ut) |> 
  arrange(.s1) |> 
  knitr::kable(caption = "Records of missing survey dates")
```

### The surveyitem table

```{r}
s2 <- fm_surveyitem(key, trim = FALSE)
s2 |> glimpse()
```

### The surveyitem_dtl table

```{r}

```


### The catch table (Survey item table)

pending further coding ...


## The wide tables

Combining these three data tables into a single wide-table is very common delivery approach when the downstream analysis is based on some kind of a spreadsheet software. The problem here though is that each measurements in the trip table gets repeated by the number of species recorded in the catch table and then the records associated with the sampling site get repeated by the number of trips. E.g. if on one sampling site within one day one samples 10 trips and for each of those 10 trips we measure 5 species we have 50 (10 trips x 5 species) repeated records of the variables associated with the sampling site table.

Wide-tables where one has repeated records of the same measure create a bit of a problem in statistical analysis, in particular when there are a lot of variables (columns) in such a wide-table. In order that any code generated is delivering what is intended the person using the wide-table has to have a full knowledge of the data-model in the first place. Which defies hence the logic of providing a wide table.

Of course on can access the wide tables provided by FM via {fmr} as shown below. Although wide tables are often used when using spreadsheet software, it is not recommended to use them for downstream analysis in R:

### landing F
```{r}
fm_landingF() |> glimpse()
```

### landingV
```{r}
fm_landingV() |> glimpse()
```

